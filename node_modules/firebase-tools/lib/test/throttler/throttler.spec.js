"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const sinon = require("sinon");
const chai_1 = require("chai");
const queue_1 = require("../../throttler/queue");
const stack_1 = require("../../throttler/stack");
const TEST_ERROR = new Error("foobar");
const throttlerTest = (throttlerConstructor) => {
    it("should have no waiting task after creation", () => {
        const queue = new throttlerConstructor({});
        chai_1.expect(queue.hasWaitingTask()).to.equal(false);
    });
    it("should return the task as the task name", () => {
        const handler = sinon.stub().resolves();
        const q = new throttlerConstructor({
            handler,
        });
        const stringTask = "test task";
        q.add(stringTask);
        chai_1.expect(q.taskName(0)).to.equal(stringTask);
    });
    it("should return the index as the task name", () => {
        const handler = sinon.stub().resolves();
        const q = new throttlerConstructor({
            handler,
        });
        q.add(2);
        chai_1.expect(q.taskName(0)).to.equal("index 0");
    });
    it("should return 'finished task' as the task name", () => {
        const handler = sinon.stub().resolves();
        const q = new throttlerConstructor({
            handler,
        });
        q.add(2);
        q.close();
        return q.wait().then(() => {
            chai_1.expect(q.taskName(0)).to.equal("finished task");
        });
    });
    it("should handle function tasks", () => {
        const task = sinon.stub().resolves();
        const q = new throttlerConstructor({});
        q.add(task);
        q.close();
        return q.wait().then(() => {
            chai_1.expect(task.callCount).to.equal(1);
            chai_1.expect(q.complete).to.equal(1);
            chai_1.expect(q.success).to.equal(1);
            chai_1.expect(q.errored).to.equal(0);
            chai_1.expect(q.retried).to.equal(0);
            chai_1.expect(q.total).to.equal(1);
        });
    });
    it("should handle tasks", () => {
        const handler = sinon.stub().resolves();
        const q = new throttlerConstructor({
            handler,
        });
        q.add(4);
        q.close();
        return q.wait().then(() => {
            chai_1.expect(handler.callCount).to.equal(1);
            chai_1.expect(q.complete).to.equal(1);
            chai_1.expect(q.success).to.equal(1);
            chai_1.expect(q.errored).to.equal(0);
            chai_1.expect(q.retried).to.equal(0);
            chai_1.expect(q.total).to.equal(1);
        });
    });
    it("should not retry", () => {
        const handler = sinon.stub().rejects(TEST_ERROR);
        const q = new throttlerConstructor({
            handler,
            retries: 0,
        });
        q.add(4);
        q.close();
        return q
            .wait()
            .then(() => {
            throw new Error("handler should have rejected");
        })
            .catch((err) => {
            chai_1.expect(err).to.equal(TEST_ERROR);
        })
            .then(() => {
            chai_1.expect(handler.callCount).to.equal(1);
            chai_1.expect(q.complete).to.equal(1);
            chai_1.expect(q.success).to.equal(0);
            chai_1.expect(q.errored).to.equal(1);
            chai_1.expect(q.retried).to.equal(0);
            chai_1.expect(q.total).to.equal(1);
        });
    });
    it("should retry the number of retries, plus one", () => {
        const handler = sinon.stub().rejects(TEST_ERROR);
        const q = new throttlerConstructor({
            backoff: 0,
            handler,
            retries: 3,
        });
        q.add(4);
        q.close();
        return q
            .wait()
            .then(() => {
            throw new Error("handler should have rejected");
        })
            .catch((err) => {
            chai_1.expect(err).to.equal(TEST_ERROR);
        })
            .then(() => {
            chai_1.expect(handler.callCount).to.equal(4);
            chai_1.expect(q.complete).to.equal(1);
            chai_1.expect(q.success).to.equal(0);
            chai_1.expect(q.errored).to.equal(1);
            chai_1.expect(q.retried).to.equal(3);
            chai_1.expect(q.total).to.equal(1);
        });
    });
    it("should handle tasks in concurrency", () => {
        const callCountMap = new Map();
        const handler = (task) => {
            let count = callCountMap.get(task);
            if (!count) {
                count = 0;
            }
            count += 1;
            callCountMap.set(task, count);
            if (count > 2) {
                return Promise.resolve();
            }
            return Promise.reject();
        };
        const q = new throttlerConstructor({
            backoff: 0,
            concurrency: 2,
            handler,
            retries: 2,
        });
        q.add("1");
        q.add("2");
        q.add("3");
        q.close();
        return q
            .wait()
            .catch((err) => {
            throw new Error("handler should have passed ");
        })
            .then(() => {
            chai_1.expect(q.complete).to.equal(3);
            chai_1.expect(q.success).to.equal(3);
            chai_1.expect(q.errored).to.equal(0);
            chai_1.expect(q.retried).to.equal(6);
            chai_1.expect(q.total).to.equal(3);
        });
    });
    it("should retry the number of retries for mutiple identical tasks", () => {
        const handler = sinon
            .stub()
            .rejects(TEST_ERROR)
            .onCall(2)
            .resolves(0)
            .onCall(5)
            .resolves(0)
            .onCall(8)
            .resolves(0);
        const q = new throttlerConstructor({
            backoff: 0,
            concurrency: 1,
            handler,
            retries: 2,
        });
        q.add(5);
        q.add(5);
        q.add(5);
        q.close();
        return q
            .wait()
            .catch((err) => {
            throw new Error("handler should have passed");
        })
            .then(() => {
            chai_1.expect(handler.callCount).to.equal(9);
            chai_1.expect(q.complete).to.equal(3);
            chai_1.expect(q.success).to.equal(3);
            chai_1.expect(q.errored).to.equal(0);
            chai_1.expect(q.retried).to.equal(6);
            chai_1.expect(q.total).to.equal(3);
        });
    });
    it("should return the result of task", () => {
        const handler = (task) => {
            return Promise.resolve(`result: ${task}`);
        };
        const q = new throttlerConstructor({
            handler,
        });
        chai_1.expect(q.run(2)).to.eventually.to.equal("result: 2");
        chai_1.expect(q.run(3)).to.eventually.to.equal("result: 3");
    });
};
describe("Throttler", () => {
    describe("Queue", () => {
        throttlerTest(queue_1.default);
    });
    describe("Stack", () => {
        throttlerTest(stack_1.default);
    });
});
exports.createTask = (name, resolved) => {
    return new Promise((res) => {
        let resolve = () => {
            throw new Error("resolve is not set");
        };
        let reject = () => {
            throw new Error("reject is not set");
        };
        let startExecute = () => {
            throw new Error("startExecute is not set");
        };
        const promise = new Promise((s, j) => {
            resolve = s;
            reject = j;
        });
        const startExecutePromise = new Promise((s, j) => {
            startExecute = s;
        });
        res({
            name,
            promise,
            resolve,
            reject,
            startExecute,
            startExecutePromise,
        });
        if (resolved) {
            resolve();
        }
    });
};
exports.createHandler = (orderList) => {
    return (task) => {
        task.startExecute();
        return task.promise.then(() => {
            orderList.push(task.name);
        });
    };
};
//# sourceMappingURL=throttler.spec.js.map